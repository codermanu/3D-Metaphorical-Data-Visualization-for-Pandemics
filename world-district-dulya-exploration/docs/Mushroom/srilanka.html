<!DOCTYPE html>
<html lang="en">
  <head>
    <title>COVID-19 Data Visualization</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />

    <!-- 2D CHARTS -->
    <script src=https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.3/Chart.min.js></script>
    <script data-require="jquery@*" data-semver="2.2.0" src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js"></script>
    <script data-require="bootstrap@*" data-semver="3.3.6" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
    <link data-require="bootstrap-css@3.3.6" data-semver="3.3.6" rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.css"
    />
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.11.3/themes/smoothness/jquery-ui.css" />
    <script src="https://code.jquery.com/ui/1.11.3/jquery-ui.min.js"></script>

     <!-- ADD MAIN TITLE -->
    <div id="mymenu" class="mymenu">
    <span id="maintitle" style="font-size:18px;margin-top: 10px;">COVID-19 Data Visualization<br>Sri Lanka - District Level</span>
    <br/><br/>
    <span id="subtitle" style="font-size:18px;margin-top: 10px;color: rgb(94, 191, 230);"> </span>
    <br/>
    <span id = "WardLevel">
    <a href="../Dulya.github.io/index.html" class="btnMenu" title="Ward Level" >
      <img src="img/ward2.png" alt="Main Map" style="width:20px;height:20px;border:0;right: 50000px;" >
      Ward Level
    </a>
  </span>
  <br/> 
  <a href="../covid-19-remix/c19-remix.html" class="btnMenu" title="World Level">
    <img src="img/world.png" alt="Main Map" style="width:20px;height:20px;border:0">
    World Level
  </a>
   

    </div>

    <script>
      function showMenu(){
        var menu = document.getElementById("mymenu");
        menu.style.display = "block";
      }
      function hideMenu(){
        var menu = document.getElementById("mymenu");
        menu.style.display = "none";
      }
      function changeMenuTitle(txt){
        var title = document.getElementById("maintitle");
        title.innerHTML = txt;

      }
      function changeSubTitle(txt){
        var title = document.getElementById("subtitle");
        title.innerHTML = txt;
        // changeMenuTitle("Covid-19 Data for "+wards[polygon.indexID].name+"");

      }
      showMenu();
      hideWardLevel();

      function showWardLevel(){
        var menu = document.getElementById("WardLevel");
        menu.style.display = "block";
      }
      function hideWardLevel(){
        var menu = document.getElementById("WardLevel");
        menu.style.display = "none";
      }

    </script>
    
    

    <style>
      body {
        font-family: Monospace;
        background-color: #000;
        color: #000;
        margin: 0px;
        overflow: hidden;
      }
    </style>
  </head>

  <!-- Tooltip -->
  <div id="tooltip"><span>123</span></div>

  <body>
    <script src="js/three.js"></script>
    <!-- carousel js files -->
    <script src="js/Carousel.js"></script>
    <script src="js/Connector.js"></script>
    <script src="js/Structure.js"></script>
    <script src="js/DataExplorer.js"></script>
    <script src="js/geoxml3.js"></script>
    <script src="js/encode.js"></script>
    <script src="js/PlanetoMap.js"></script>
    <script src="js/CaseVisualizer.js"></script>
    <script src="js/GlobalFunctions.js"></script>
    <script src="js/DataVisualizer.js"></script>


    <!-- carousel libs files -->
    <script src="js/libs/lodash.js"></script>
    <script src="js/libs/stats.min.js"></script>
    <script src="js/libs/tween.min.js"></script>

    <!-- carousel renderers files -->
    <script src="js/renderers/CanvasRenderer.js"></script>
    <script src="js/renderers/Projector.js"></script>
    <script src="js/renderers/CSS3DRenderer.js"></script>
    <script src="js/renderers/CSS2DRenderer.js"></script>


    <!-- <script src="./cs291-master/lib/Coordinates.js"></script> -->
    <script src="./cs291-master/lib/OrbitAndPanControls.new.js"></script>
    <!-- <script src="./cs291-master/lib/dat.gui.min.js"></script> -->
    <!-- <script src="./tween.js-master/src/Tween.js"></script> -->
    <script src="./js/mushroom.js"></script>
    <script src="./js/distrctwithpixce.js"></script>

    <script src="js/controls/OrbitControls.js"></script>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/92/three.min.js"></script>
    <script src="js/OrbitControl.js"></script>
    <!-- <script src="js/OrbitAndPanControls.new.js"></script> -->

    <!-- <script src="https://cdn.rawgit.com/mrdoob/three.js/dev/examples/js/controls/OrbitControls.js"></script> -->
    <script src="https://cdn.rawgit.com/mrdoob/three.js/dev/examples/js/renderers/CSS3DRenderer.js"></script>
    <script src="https://cdn.rawgit.com/mrdoob/three.js/dev/examples/js/libs/stats.min.js"></script>

    <!-- Load the csv file -->

    <script src="https://d3js.org/d3-collection.v1.min.js"></script>
    <script src="https://d3js.org/d3-dispatch.v1.min.js"></script>
    <script src="https://d3js.org/d3-dsv.v1.min.js"></script>
    <script src="https://d3js.org/d3-request.v1.min.js"></script>
    <script src="js/loaders/OBJLoader.js"></script>

    <!-- 2D Charts -->
    <div id="myModal" class="modal">
    <span class="close" id="close_btn">&times;</span>
    <canvas id="chart" width="450px" height="400px" ></canvas>
    </div>

    <!-- Tooltip -->
    <script
      type="text/javascript"
      src="http://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.min.js"
    ></script>
    <link rel="stylesheet" href="./css/tooltip.css" type="text/css" />

    <link rel="stylesheet" href="./css/dataexplore.css" type="text/css" />


    <!-- <script src="explorer/onClickMushroom.js"></script> -->

    <!-- DataExplorer -->

    <script src="js/DataVisualizer.js"></script>
    <script src="js/CaseVisualizer.js"></script>

    <!-- <script src="cone.js"></script> -->
    <script>
      /*global THREE, Coordinates, document, window, dat*/
      var shroomGroup;
      var camera, scene, renderer, projector;
      var cameraControls, effectController;

      var clock = new THREE.Clock();
      var canvasWidth = 640;
      var canvasHeight = 480;

      var rSeg = 32;
      var hSeg = 8;

      var showSpotCam = false;
      var isDaytime = true;
      var animateWater = true;
      var closeView = false;

      var bubbleCount = 50;
      var bubblePartSys;
      var bubbleTextureDay, bubbleTextureNight; //so can switch for night and day

      var objects = []; //list of mesh  in the scene that check for onmousedown

      var daylight, nightlight; //arrays to hold lights for day and nights
      var riverMat; //made global so can access for animation in render func

      var mushroomList = []; //list of Mushroom objects (mushroom.js)
      var smallMushrooms = []; //list of generated mushrooms

      // carousel variables
      var dataset = [];
      //var boundaryId=48;
      var fields = [];
      var subdimensions;
      var nonDimensionalFields = ["caseid", "boundaryid", "lat", "lon", "district","medicalCondition"];

      var MapElement = function (id, x, y, z, rx) {
        var div = document.createElement("div");
        div.id = id;
        div.style.width = "1200px";
        div.style.height = "950px";
        //	div.style.backgroundColor = 'red';

        var object = new THREE.CSS3DObject(div);
        object.position.set(x, y, z);
        object.rotation.x = rx;
        return object;
      };
      //carousel variables
      var controls;
      var iniZoom; //= controls.target.distanceTo( controls.object.position )
      var isCarouselSelected = false;
      var isCarousel = false;
      var parent;
      var clickedSlice;
      var dataExplorer;
      var dataVisualizer;
      var caseVisualizer;
      var CarouselSelected =false;
      var isMushroomSelected = true;

      var container, stats;
      var camera, scene, renderer, renderer1, controls;
      var webGLRenderer, dynamicMapRenderer, canvasRenderer, labelRenderer;


      var sphere;
      //var cone;
      // var object;
      var objects = [];

      init();
      importCSV();
      //drawMushroom();
      animate();

      function dataexplore_csv(district_id) {
        d3.csv("data-explore/districtdata.csv", function (data) {
          // console.log("csv data", data);
          //select cases according to the given boundary
          dataset = data.filter(function (report) {
            var bid = 0;
            try {
              bid = parseInt(report.boundaryid);
            } catch (e) {
              console.log("error", e);
            }
            // return bid == polygon.indexID;
            return bid == parseInt(district_id);
          });
          //select dimensional fields

          // console.log("selected dataset", dataset);
          if (dataset.length > 0) {
            fields = Object.keys(dataset[0]).filter(function (key) {
              return nonDimensionalFields.indexOf(key) == -1;
            });
          }

          //finding subdimenions from the dataset values
          var fieldValues = {};
          subdimensions = {};
          fields.forEach(function (field) {
            fieldValues[field] = [];
            subdimensions[field] = [];
          });

          dataset.forEach(function (record) {
            fields.forEach(function (field) {
              fieldValues[field].push(record[field]);
            });
          });

          fields.forEach(function (field) {
            fieldValues[field] = Array.from(new Set(fieldValues[field]));
            if (isSubdimension(fieldValues[field])) {
              subdimensions[field] = fieldValues[field];
            }
          });
          console.log("dataset loaded!");
          console.log("######## Dataset #########");
          console.log("Main dimensions = ", fields);
          console.log("Main dimensions info = ", subdimensions);
          console.log("##########################");

          carouselinit();
        });

        //conditions for selecting subdimesnions
        var isSubdimension = function (dimArray) {
          var threshold = (dataset.length * 10) / 100;
          if (!dimArray.some(isNaN)) {
            return false;
          }

          // if (dimArray.length >= threshold) {
          //   return false;
          // }

          return true;
        };
      }

      function carouselinit() {
        isCarousel = true;
     
        var metaphorDescriptor = new MetaphorDescriptor(
          0,
          null,
          Object.keys(subdimensions),
          [],
          undefined
        );
        console.log(metaphorDescriptor);
        parent = CreateNewNode(metaphorDescriptor);

        caseVisualizer = new CaseVisualizer(scene, subdimensions);
        dataVisualizer = new DataVisualizer(dataset, caseVisualizer);
        dataExplorer = new DataExplorer(
          scene,
          parent,
          subdimensions,
          dataVisualizer
        );

        console.log(dataExplorer);

        // staticMapGroup.add(parent.metaphor);
        scene.add(parent.metaphor);

        parent.metaphor.userData.name = "parentMetaphor"; //Level1-Carousel
        //console.log("PARENT",parent.metaphor)

      }
    
      function removecarousel(){
        console.log("REMOVE CAROUSEL")
        hideWardLevel();
        changeSubTitle(" ");
     
        for( var i = scene.children.length - 1; i >= 0; i--) {
          obj = scene.children[i];
         //console.log("SCENE CHILDREN", scene.children)
         if(
          obj.userData.name=="parentMetaphor" || 
          //obj.userData.name=="parentMetaphorChildren"||
          obj.type=="Line" ||
          obj.type=="Group"
          )
          {
          scene.remove(obj); 
          isCarousel=false;


        }
     }

    }

      function removeChart(){
    
        if(isCarousel==false){
          var els = $('#chart'), saved = els.clone (true);
          els.remove ();
          document.getElementById("myModal").style.display ="none";
        }
        
        saved.appendTo ($('#myModal'));
          }

      function init() {
        // console.log(districtWithpxl);
        container = document.createElement("div");
        document.body.appendChild(container);

        // scene

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.Fog(0xcce0ff, 500, 10000);

        // camera

        camera = new THREE.PerspectiveCamera(
          25,
          window.innerWidth / window.innerHeight,
          1,
          10000
        );
        
        camera.position.set(-2.198618297315242, 802.3112481029098, 2755.1754787778136);

        group = new THREE.Group();

        // lights

        var light, materials;

        scene.add(new THREE.AmbientLight(0x666666));

        light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(50, 200, 100);
        light.position.multiplyScalar(1.3);

        light.castShadow = true;

        light.shadow.mapSize.width = 1024;
        light.shadow.mapSize.height = 1024;

        var d = 300;

        light.shadow.camera.left = -d;
        light.shadow.camera.right = d;
        light.shadow.camera.top = d;
        light.shadow.camera.bottom = -d;

        light.shadow.camera.far = 1000;

        scene.add(light);

        // ground
        var PLANE_SIZE = 2000;
        var MAP_SIZE = 512;

        var ZOOM = 7; //Static Map zoom

        var loader = new THREE.TextureLoader();
        var groundTexture = loader.load(
          "http://maps.googleapis.com/maps/api/staticmap?center=" +
            " 7.8731, 80.7718" +
            "&scale=2&zoom=" +
            ZOOM +
            "&size=" +
            MAP_SIZE +
            "x" +
            MAP_SIZE +
            "&maptype=roadmap&sensor=false&path=color:red|weight:2|fillcolor:white|enc:" +
            "&key=AIzaSyBp7LT-AfWOztGLh-L5_5YRmw5HeNiiNYA"
        );
        //isCarousel = true;
        //var groundTexture = loader.load('download.jpeg');
        groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set(1, 1);
        groundTexture.anisotropy = 16;
        Math.PI;

        var groundMaterial = new THREE.MeshLambertMaterial({
          map: groundTexture,
        });

        var mesh = new THREE.Mesh(
          new THREE.PlaneBufferGeometry(2000, 2000),
          groundMaterial
        );
        mesh.position.y = -200;
        mesh.rotation.x = -Math.PI / 2;
        mesh.receiveShadow = true;
        scene.add(mesh);

        var mapObject = new MapElement("googleMap", 0, 0, 540, 270);
        group.add(mapObject);
        group.position.y = -459;

        group.rotation.x = 1.3819063267948963; // - Math.PI / 2;
        group.rotation.y = -3.14159265358979; // - Math.PI;

        scene.add(group);

        // renderer

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);

        renderer1 = new THREE.CSS3DRenderer();
        renderer1.setSize(window.innerWidth, window.innerHeight);

        renderer1.domElement.style.position = "absolute";
        // renderer1.domElement.style.top = 0;

        container.appendChild(renderer1.domElement);
        container.appendChild(renderer.domElement);

        renderer.gammaInput = true;
        renderer.gammaOutput = true;

        renderer.shadowMap.enabled = true;

        // controls
        controls = new THREE.OrbitControls(camera);
        controls.maxPolarAngle = Math.PI * 0.5;
        controls.minDistance = 1000;
        controls.maxDistance = 5000;
        // performance monitor

        // stats = new Stats();
        // container.appendChild(stats.dom);

      window.addEventListener("mousedown", onDocumentMouseDown, false);

        //This listener will be watching for click events
        // document.addEventListener("mousedown", onDocumentMouseDown, false);
      }
      //window click events
      var mouseDragCount = 0;
      window.addEventListener("mouseup", onMouseUp, false);
      window.addEventListener("mousedown", onMouseDown, false);
      window.addEventListener("resize", onWindowResize, false);
      window.addEventListener('mousemove', onMouseMove, false);

      function onMouseUp(event) {
        console.log("MouseUp");
        event.preventDefault();
       
       
        // isModalDragging = false; // if this is true, we should make it false anyway
        // endDragCone(event);
      }

      function onMouseDown(event) {
        event.preventDefault();
        // startDragCone(event);
        console.log("mouseDown");
        console.log(scene.children)


        if (mouseDragCount < 5) {
          console.log("mousedrag");
          var raycaster = new THREE.Raycaster();
          var mouse = new THREE.Vector2();
          var intersects;
          mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
          mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
          raycaster.setFromCamera(mouse, camera);

          if (isCarousel) {
            var prevNumLevels = dataExplorer.levels.length;
            // get all segments and buttons in the scene
            var i = 0;
            var children_segments = [];
            var allNodes = dataExplorer.getAllNodes();

            for (i = 0; i < allNodes.length; i++) {
              children_segments = children_segments.concat(
                allNodes[i].metaphor.children
              );
            }

            var intersects = raycaster.intersectObjects(
              children_segments,
              true
            );
            console.log("Child-intersects", intersects);

            // console.log("allActiveNodes",allActiveNodes);
            var time = new Date() * 0.001;
            for (i = 0; i < intersects.length; i++) {
              if (
                intersects[i].object.geometry.type == "ExtrudeGeometry" ||
                intersects[i].object.geometry.type == "SphereGeometry"
              ) {                

                isSegmentClicked = true;
                console.log(scene.children)


                // When the user clicks on the button, open the modal

                clickedSlice = intersects[i].object;

                clickedSlice.select(dataExplorer);
                /*
							if(clickedSlice.getType() == "segment"){
								//clickedDimension = clickedSlice.getDimension();
								clickedSlice.select(dataExplorer);
							}else if(clickedSlice.getType() == "middle_button"){
								clickedSlice.select(dataExplorer);
              }*/
              for( var i = scene.children.length - 1; i >= 0; i--) { 
                  if(scene.children[i].userData.node){
                    obj = scene.children[i];
                    console.log(scene.children[i])
                    //  scene.remove(obj); 

                  }else{
                    console.log("not a node",scene.children[i].userData.node)

                  }
                    
}

                break;
              }
            }
            /*
					var curNumLevels = dataExplorer.levels.length;
					if(curNumLevels>prevNumLevels && curNumLevels>3){
						var lev = curNumLevels-1;
						var zooms = [0,0,0,1.36*iniZoom,1.5*iniZoom, 1.7*iniZoom];

						var curZoom = controls.target.distanceTo( controls.object.position );
						
						if (curZoom < zooms[lev]){
							controls.zoomOut(zooms[lev]);
							controls.update();
						}
						
					}*/
          }
        }
        mouseDragCount = 0;
      }

      //import the csv

      function importCSV() {
        console.log("csv importing called");
        var xmlhttp = new XMLHttpRequest();
        xmlhttp.onreadystatechange = function () {
          if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
            console.log("imported");
            var district_data = CSVToArray(xmlhttp.responseText, ";");
            drawMushroom(district_data);

            //district,totalcases,recovered,no_deaths
            // district_data.forEach(function (e) {
            //   drawMushroom(e);
            //   console.log(e);
            // });
          }
        };

        xmlhttp.open("GET", "./dataset-district/districtcsv.csv", true);
        xmlhttp.send();
      }

      function CSVToArray(strData, strDelimiter) {
        // Check to see if the delimiter is defined. If not,
        // then default to comma.
        strDelimiter = strDelimiter || ",";

        // Create a regular expression to parse the CSV values.
        var objPattern = new RegExp(
          // Delimiters.
          "(\\" +
            strDelimiter +
            "|\\r?\\n|\\r|^)" +
            // Quoted fields.
            '(?:"([^"]*(?:""[^"]*)*)"|' +
            // Standard fields.
            '([^"\\' +
            strDelimiter +
            "\\r\\n]*))",
          "gi"
        );

        // Create an array to hold our data. Give the array
        // a default empty first row.
        var arrData = [[]];

        // Create an array to hold our individual pattern
        // matching groups.
        var arrMatches = null;

        // Keep looping over the regular expression matches
        // until we can no longer find a match.
        while ((arrMatches = objPattern.exec(strData))) {
          // Get the delimiter that was found.
          var strMatchedDelimiter = arrMatches[1];

          // Check to see if the given delimiter has a length
          // (is not the start of string) and if it matches
          // field delimiter. If id does not, then we know
          // that this delimiter is a row delimiter.
          if (
            strMatchedDelimiter.length &&
            strMatchedDelimiter != strDelimiter
          ) {
            // Since we have reached a new row of data,
            // add an empty row to our data array.
            arrData.push([]);
          }

          // Now that we have our delimiter out of the way,
          // let's check to see which kind of value we
          // captured (quoted or unquoted).
          if (arrMatches[2]) {
            // We found a quoted value. When we capture
            // this value, unescape any double quotes.
            var strMatchedValue = arrMatches[2].replace(
              new RegExp('""', "g"),
              '"'
            );
          } else {
            // We found a non-quoted value.
            var strMatchedValue = arrMatches[3];
          }

          // Now that we have our value string, let's add
          // it to the data array.
          arrData[arrData.length - 1].push(strMatchedValue);
        }

        // Return the parsed data.
        return arrData;
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer1.setSize(window.innerWidth, window.innerHeight);

        // webGLRenderer.setSize(window.innerWidth, window.innerHeight);
        // dynamicMapRenderer.setSize(window.innerWidth, window.innerHeight);
        // canvasRenderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);

        render();
        // stats.update();
      }

      function render() {
        renderer1.render(scene, camera);
        renderer.render(scene, camera);
      }

      // Functions related to mushroom

      function drawMushroom(disc_data_arr) {
        var shroomGroup = new THREE.Object3D();

        shroomGroup.position.copy(new THREE.Vector3(0, 0, 0));

        // console.log(disc_data_arr);

        // Get the min and max values of totalcases,recoveries,death
        var totalcases_Max = 0;
        var totalcases_Min = 10000;

        var recoveries_Max = 0;
        var recoveries_Min = 1000;

        var deaths_Max = 0;
        var deaths_Min = 1000;

        disc_data_arr.forEach((dataset) => {
          // console.log(dataset);

          var disc_totalcases = parseInt(dataset[1]);
          var disc_recoveries = parseInt(dataset[2]);
          var disc_death = parseInt(dataset[3]);

          // console.log(totalcases_Max);

          if (disc_totalcases > totalcases_Max) {
            totalcases_Max = disc_totalcases;
          }
          if (disc_totalcases < totalcases_Min) {
            totalcases_Min = disc_totalcases;
          }

          if (disc_recoveries > recoveries_Max) {
            recoveries_Max = disc_recoveries;
          }
          if (disc_recoveries < recoveries_Min) {
            recoveries_Min = disc_recoveries;
          }

          if (disc_death > deaths_Max) {
            deaths_Max = disc_death;
          }
          if (disc_death < deaths_Min) {
            deaths_Min = disc_death;
          }
        });

        console.log("totalcases_Max", totalcases_Max);
        console.log("totalcases_Min", totalcases_Min);
        console.log("recoveries_Max", recoveries_Max);
        console.log("recoveries_Min", recoveries_Min);
        console.log(" deaths_Max", deaths_Max);
        console.log("deaths_Min", deaths_Min);

        disc_data_arr.forEach((dataset, index) => {
          //discid[0],totalcases[1],recovered[2],died[3],pixcel_x[4],Pixcel_Y[5],Pixcel_Z[6]

          //calculate the capsie
          //calculate the stalk height for
          let stalkheight = 7 * Math.sqrt(parseInt(dataset[1]));

          //  let stalkheight =30+(((450-30)/totalcases_Max)*2 )*dataset[1]
          // console.log(stalkheight,dataset[7])

          //calculate the capsize
          let capsize = 25 + 2 * Math.sqrt(parseInt(dataset[2]));
          // capsize=35+(((65-18)/totalcases_Max)*2 )*dataset[2]
          //   console.log("capsize",capsize)

          //var m1 = new Mushroom(18, 30, 5, 5, 1.2, 1);-smallest one
          //var m1 = new Mushroom(65, 900, 10, 10, 1.2, 1)- largest one

          //   adding the pixcel variables
          let pixce_x = dataset[4];
          let pixce_y = dataset[5];
          let pixce_z = dataset[6];

          // Creating the length and capsize based on the data goes here

          // capSize,stalkHeight,stalkTop,stalkBottom,capScaleY, capOffsetY
          var index = new Mushroom(capsize, stalkheight, 8, 8, 0.9, 1);
          
          // calculate the death rate
          if (dataset[3] > 0) {
            let capcolor;
            const death_rate = (dataset[3] / dataset[1]) * 100;
            console.log(dataset[7]);
            console.log("deathrate", death_rate);
            // Colorscale available on https://www.htmlcsscolor.com/hex/F40909
            if (death_rate > 1) {
              capcolor = "0xf40909";
            } else if (death_rate > 0.5) {
              capcolor = "0xf63a3a";
            } else if (death_rate > 0.2) {
              capcolor = "0xf86161";
            } else {
              capcolor = "0xfbaeae";
            }

            index.setColors(capcolor, "0xbbba00", "0xffba00");
          } else {
            index.setColors("0xffff00", "0xbbba00", "0xffba00");
          }
          //capcolor,undercapcolor,stalkcolor

          //#BAFF00
          index.setTextures(
            "./img/cap1.png",
            "./img/ucap1.png",
            "./img/stalk1.png"
          );

          index.growIt();
          //discid[0],totalcases[1],recovered[2],died[3],pixcel_x[4],Pixcel_Y[5],Pixcel_Z[6]
          index.model.id = dataset[0];
          index.model.children[0].id = "cap" + dataset[0];
          index.model.children[1].id = "ucap" + dataset[0];
          index.model.children[2].id = "stalk" + dataset[0];
          index.model.children[2].material.map.wrapT = THREE.RepeatWrapping;
          index.model.children[0].material.map.wrapS = THREE.RepeatWrapping;
          index.model.children[0].material.map.repeat.set(3, 1);
          index.model.userData= {distrctId:dataset[0],totalcases:dataset[1],recovered:dataset[2],died:dataset[3],districtName:dataset[7]}
          // console.log(index.model)
       
          // adding the single mushroom
          index.model.position.copy(
            new THREE.Vector3(pixce_x, pixce_y, pixce_z)
          );
          shroomGroup.add(index.model);

          // Used to detect the mushroom
          //push (cap, undercap, stalk) onto object array so can detect intersect when click
          for (var i = 0; i < 3; i++) {
            objects.push(index.model.children[i]);
          }

          // console.log(objects);
          mushroomList.push(index);

          //use traverse code snippet from udacity cs291
          mushroomList[0].model.traverse(function (object) {
            if (object instanceof THREE.Mesh) {
              object.castShadow = true;
              //object.receiveShadow = true;
            }
          });
        });
        shroomGroup.userData.name = "Mushrooms"; 
        scene.add(shroomGroup);
      }

      /*MUSHROOM ON CLICK*/
      
      function onDocumentMouseDown(event) {

      // console.log("onDocumentMouseDown")
        event.preventDefault();

        /*getBoundingClientRect() -->
        gives the element's position relative to the browser's visile viewport.
        https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
        */  
        var canvasPosition = renderer.domElement.getBoundingClientRect();

        /*clientX/Y  -->  
        gives the mouse position relative to the browser's visible viewport.
        */

        /*we then just have to find the difference between the two
        to get the mouse position in "canvas-space"
        */

        var mouseX = event.clientX - canvasPosition.left;
        var mouseY = event.clientY - canvasPosition.top;

        console.log(canvasPosition.left, canvasPosition.top);
        console.log(mouseX, mouseY);

        /* the new way: simpler creation of raycaster */
        /* tutorial: http://soledadpenades.com/articles/three-js-tutorials/object-picking/ */
        var mouseVector = new THREE.Vector3( 
        2 * (mouseX / canvasWidth) - 1,                               
        1 - 2 * (mouseY / canvasHeight));

        //https://stackoverflow.com/questions/29366109/three-js-three-projector-has-been-moved-to

        var raycaster = new THREE.Raycaster(); 
        var mouse = new THREE.Vector2();   

        // calculate mouse position in normalized device coordinates
        // (-1 to +1) for both components
        mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

        //Adjusts the direction of the ray to point at the vector in world coordinates.
        //camera.lookAt( scene.position );

        // update the picking ray with the camera and mouse position
        raycaster.setFromCamera( mouse, camera );

        var intersects = raycaster.intersectObjects( objects );
        //console.log("intersectsMUSHROOMCLICK",intersects)

        if (intersects.length > 0 && isMushroomSelected ){
        
        
        // get the district Id from the mushroom
        var distrcit_Id=intersects[0].object.parent.userData.distrctId

        dataexplore_csv(distrcit_Id);

        console.log("distrcit_Id",distrcit_Id)

        isMushroomSelected =false;
        changeSubTitle(hovered_districtName+" District");
          if(hovered_districtName =="Colombo"){

            showWardLevel("Ward Level")
          }else{
            hideWardLevel()
          };

            
        }else if(intersects.length > 0 && isMushroomSelected ==false){

          removecarousel();
          removeChart();

          isMushroomSelected =true;
                
        }else{
         
          onMouseDown();

          
        }
    }


      /*TOOLTIP*/

      // this will be 2D coordinates of the current mouse position, [0,0] is middle of the screen.
      var mouse = new THREE.Vector2();

      var latestMouseProjection; 
      // this is the latest projection of the mouse on object (i.e. intersection with ray)
      var hoveredObj; 
      var hovered_totalCases;
      var hovered_totalDeaths;
      var hovered_totalRecovered;
      var hovered_districtName
      // this objects is hovered at the moment

      // tooltip will not appear immediately. If object was hovered shortly,
      // - the timer will be canceled and tooltip will not appear at all.
      var tooltipDisplayTimeout;

      // This will move tooltip to the current mouse position and show it by timer.
      function showTooltip() {
        var divElement = $("#tooltip");

        if (divElement && latestMouseProjection) {
          divElement.css({
            display: "block",
            opacity: 0.0
          });

          var canvasHalfWidth = renderer.domElement.offsetWidth / 2;
          var canvasHalfHeight = renderer.domElement.offsetHeight / 2;

          var tooltipPosition = latestMouseProjection.clone().project(camera);
          tooltipPosition.x = (tooltipPosition.x * canvasHalfWidth) + canvasHalfWidth + renderer.domElement.offsetLeft;
          tooltipPosition.y = -(tooltipPosition.y * canvasHalfHeight) + canvasHalfHeight + renderer.domElement.offsetTop;

          var tootipWidth = divElement[0].offsetWidth;
          var tootipHeight = divElement[0].offsetHeight;

          divElement.css({
            left: `${tooltipPosition.x - tootipWidth/2}px`,
            top: `${tooltipPosition.y - tootipHeight - 5}px`
          });

          // var position = new THREE.Vector3();
          // var quaternion = new THREE.Quaternion();
          // var scale = new THREE.Vector3();
          // hoveredObj.matrix.decompose(position, quaternion, scale);

         //console.log("TOOLTIPTEXT",hoveredObj.userData.tooltipText)

        TOOLTIPTEXT= "Recovered: "+hovered_totalRecovered +"\A" 
      
          divElement.find('span').html(hovered_districtName+
          "<br>"+"Total Cases: "+hovered_totalCases+"<br>" + 
          "Recovered: "+hovered_totalRecovered+"<br>"+
          "Deaths: "+hovered_totalDeaths+"<br>" )
         
          setTimeout(function() {
            divElement.css({
              opacity: 1.0
            });
          }, 0.5);
        }
      }

      // This will immediately hide tooltip.
      function hideTooltip() {
        var divElement = $("#tooltip");
        if (divElement) {
          divElement.css({
            display: "none"
          });
        }

      }

      // Following two functions will convert mouse coordinates
      // from screen to three.js system (where [0,0] is in the middle of the screen)
      function updateMouseCoords(event, coordsObj) {
        coordsObj.x = ((event.clientX - renderer.domElement.offsetLeft + 0.5) / window.innerWidth) * 2 - 1;
        coordsObj.y = -((event.clientY - renderer.domElement.offsetTop + 0.5) / window.innerHeight) * 2 + 1;
      }

      function handleManipulationUpdate() {
        
        var raycaster = new THREE.Raycaster(); 
        raycaster.setFromCamera(mouse, camera);
        {
          var intersects = raycaster.intersectObjects(objects);
          //console.log("objectssssssssssssssssss",intersects);

          if (intersects.length > 0) {
            latestMouseProjection = intersects[0].point;
            hoveredObj = intersects[0].object;
            hovered_totalCases=intersects[0].object.parent.userData.totalcases;
            hovered_totalDeaths=intersects[0].object.parent.userData.died;
            hovered_totalRecovered=intersects[0].object.parent.userData.recovered;
            hovered_districtName=intersects[0].object.parent.userData.districtName;
            // console.log(hovered_totalCases)
          }
        }

        if (tooltipDisplayTimeout || !latestMouseProjection) {
          clearTimeout(tooltipDisplayTimeout);
          tooltipDisplayTimeout = undefined;
          hideTooltip();
        }

        if (!tooltipDisplayTimeout && latestMouseProjection) {
          tooltipDisplayTimeout = setTimeout(function() {
            tooltipDisplayTimeout = undefined;
            showTooltip();
          }, 330);
        }
      }

      function onMouseMove(event) {
        updateMouseCoords(event, mouse);
        console.log("Mousemove");

        latestMouseProjection = undefined;
        hoveredObj = undefined;
        handleManipulationUpdate();
      }

  
    </script>
  </body>
</html>
